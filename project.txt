{"metadata":{"generator":"Captivate","generatorVersion":"10.0.0","schemaVersion":"","author":"","title":"","description":"project description","email":"","website":"","tags":"","thumbnail":"","source":"assets","durationInFrames":33414,"frameRate":30,"totalSlides":22,"width":1280,"height":720,"responsive":false,"scalable":false,"launchFile":"index.html"},"contentStructure":[{"id":"si74830","class":"TODO::Senthil","roles":{}},{"id":"si74838","class":"TODO::Senthil","roles":{}},{"id":"Text_Caption_564","class":"TODO::Senthil","instance":"Text_Caption_564","title":"ACPI Training:  Device Power States ","roles":{"textData":{}}},{"id":"Text_Caption_909","class":"TODO::Senthil","instance":"Text_Caption_909","title":"Use buttons below to move between slides and control the audio. ","roles":{"textData":{}}},{"id":"Click_Box_56","class":"TODO::Senthil","instance":"Click_Box_56","roles":{"click":{"subtype":"button"}}},{"id":"Slide17873","class":"Normal Slide","instance":"Start","thumbnail":"","children":["si74830","si74838","Text_Caption_564","Text_Caption_909","Click_Box_56"],"roles":{"slide":{"durationInFrames":249},"navigation":{"navid":"Slide17873"}}},{"id":"si74803","class":"TODO::Senthil","roles":{}},{"id":"si112559","class":"TODO::Senthil","title":"$$cpInfoCurrentSlide$$ ","roles":{"textData":{}}},{"id":"Click_Box_104","class":"TODO::Senthil","instance":"Click_Box_104","roles":{"click":{"subtype":"button"}}},{"id":"About_This_Module_text_999","class":"TODO::Senthil","instance":"About_This_Module_text_999","title":"This training module describes how to control computer device power states using the Advanced Configuration and Power Interface (ACPI) standard.  For related information, see the other modules in this series, and the ACPI specification at http://uefi.org/specifications.   This tutorial is primarily intended for ACPI firmware developers. It may also be useful for: Operating system and device driver developers OEMs building hardware containing ACPI-compatible interfaces CPU and chipset vendors Peripheral vendors  Please allow about an hour to complete this tutorial. ","roles":{"textData":{}}},{"id":"Text_Caption_1000","class":"TODO::Senthil","instance":"Text_Caption_1000","title":"Overview Introduction to ASL Describing a Device Platform Power States Describing Processors Interrupt Routing Device Power States  ","roles":{"textData":{}}},{"id":"Green_underline_174","class":"TODO::Senthil","instance":"Green_underline_174","roles":{}},{"id":"About_This_Module_1001","class":"TODO::Senthil","instance":"About_This_Module_1001","title":"ACPI Training Outline   ","roles":{"textData":{}}},{"id":"Vertical_blue_line_175","class":"TODO::Senthil","instance":"Vertical_blue_line_175","roles":{}},{"id":"Green_underline_176","class":"TODO::Senthil","instance":"Green_underline_176","roles":{}},{"id":"What_is_ACPI_1002","class":"TODO::Senthil","instance":"What_is_ACPI_1002","title":"About this Training  ","roles":{"textData":{}}},{"id":"Slide111858","class":"Normal Slide","instance":"About this Training","thumbnail":"","children":["si74803","si112559","Click_Box_104","About_This_Module_text_999","Text_Caption_1000","About_This_Module_1001","What_is_ACPI_1002"],"roles":{"slide":{"durationInFrames":1056},"navigation":{"navid":"Slide111858"}}},{"id":"Device_Power_State_Transitions","class":"TODO::Senthil","instance":"Device_Power_State_Transitions","title":"ACPI defines a set of Device Power States, called Device States or D-States. The D-States range from D0, which is the normal, fully on  operational state, to D3, which is the deepest standby state.   All states other than D0 are non-operational states that typically consume less power, and require time to be brought back to the D0 state. The following table from the ACPI Specification shows the relationship between D-states:   ","roles":{"textData":{}}},{"id":"Green_underline_112","class":"TODO::Senthil","instance":"Green_underline_112","roles":{}},{"id":"What_is_ACPI_858","class":"TODO::Senthil","instance":"What_is_ACPI_858","title":"Device Power States ","roles":{"textData":{}}},{"id":"Click_Box_30","class":"TODO::Senthil","instance":"Click_Box_30","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1003","class":"TODO::Senthil","instance":"Text_Caption_1003","title":"In non-operational power states, including the deepest D3 state, some devices may consume a small amount of power in order to enable wake logic to function.  ","roles":{"textData":{}}},{"id":"Image_247","class":"TODO::Senthil","instance":"Image_247","roles":{}},{"id":"Slide85337","class":"Normal Slide","instance":"Device Power States","thumbnail":"","children":["si74803","si112559","Device_Power_State_Transitions","What_is_ACPI_858","Click_Box_30","Text_Caption_1003","Image_247"],"roles":{"slide":{"durationInFrames":1149},"navigation":{"navid":"Slide85337"}}},{"id":"Green_underline_182","class":"TODO::Senthil","instance":"Green_underline_182","roles":{}},{"id":"What_is_ACPI_1019","class":"TODO::Senthil","instance":"What_is_ACPI_1019","title":"Device Power States (continued) ","roles":{"textData":{}}},{"id":"Click_Box_107","class":"TODO::Senthil","instance":"Click_Box_107","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1021","class":"TODO::Senthil","instance":"Text_Caption_1021","title":"By changing power states, devices can participate in the overall platform power policy that is used to balance system performance needs with power consumption and battery life. Devices that are not actively being used can be placed into lower power states to reduce power consumption.   Device power states generally consume less power and require more time to be brought back to the D0 state: If a device is used frequently or is needed for some high-priority process, it may be placed into a shallower state that can be exited quickly.  If a device is unused for a long period of time, or requires very little time to transition to the D0 (active) state, it may be placed into a deeper power state.  If a device can generate wake events from only a subset of D-states, then the OS power policy may limit the D-state to one where wake is supported (for example, D2 but not D3).  ","roles":{"textData":{}}},{"id":"Slide112536","class":"Normal Slide","instance":"Device Power States 2","thumbnail":"","children":["si74803","si112559","What_is_ACPI_1019","Click_Box_107","Text_Caption_1021"],"roles":{"slide":{"durationInFrames":1533},"navigation":{"navid":"Slide112536"}}},{"id":"What_is_ACPI_text_963","class":"TODO::Senthil","instance":"What_is_ACPI_text_963","title":"ACPI defines control methods that are used by Operating System Power Management (OSPM) to put devices into D-states:   _PS0 is the control method that puts the device in the D0 device state (device fully on). _PS1 is the control method that puts the device in the D1 device state. _PS2 is the control method that puts the device in the D2 device state. _PS3 is the control method that puts the device in the D3 device state (device off).  The above methods take no arguments and return no values. The methods should not return until the transition to the requested D-State has completed.   Additional objects are defined to describe relationships between D-states and System States (S-States), as well as D-states that support wakes from each S-state.   _PSC (Power State Current) is an object that evaluates to the deviceâ€™s current power state. This can be a control method that returns the current power state, or simply an integer value that is updated by the _PS0/1/2/3 methods.   _SxD objects are used to describe the shallowest D-State supported by a device in a corresponding S-state. OSPM is free to pick a deeper power state than specified. Since S1 and S2 are rarely used, these objects are also rare; generally OSPM picks the deepest supported state for all devices prior to entering an S-state.  Control methods are also defined to enable/disable device wake mechanisms. See the Device Wake Mechanisms section.  ","roles":{"textData":{}}},{"id":"Green_underline_156","class":"TODO::Senthil","instance":"Green_underline_156","roles":{}},{"id":"What_is_ACPI_964","class":"TODO::Senthil","instance":"What_is_ACPI_964","title":"Control Methods ","roles":{"textData":{}}},{"id":"Click_Box_90","class":"TODO::Senthil","instance":"Click_Box_90","roles":{"click":{"subtype":"button"}}},{"id":"Slide110983","class":"Normal Slide","instance":"Control Methods","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_963","What_is_ACPI_964","Click_Box_90"],"roles":{"slide":{"durationInFrames":3057},"navigation":{"navid":"Slide110983"}}},{"id":"What_is_ACPI_text_969","class":"TODO::Senthil","instance":"What_is_ACPI_text_969","title":"A Full Device object uses ACPI to enumerate and describe a device that cannot be discovered by a bus enumerator such as PCI or USB. Devices that are ACPI-enumerated must provide control methods that allow OSPM to put these devices into supported D-states, and to enable or disable wake mechanisms. This includes ACPI device objects containing a Hardware ID (_HID) object.   If an _HID device contains a _PS1, _PS2, or _PS3 method, it must also contain both a _PS0 method and a _PSC method.  ","roles":{"textData":{}}},{"id":"Green_underline_160","class":"TODO::Senthil","instance":"Green_underline_160","roles":{}},{"id":"What_is_ACPI_970","class":"TODO::Senthil","instance":"What_is_ACPI_970","title":"Full Device Descriptor Use ","roles":{"textData":{}}},{"id":"Click_Box_92","class":"TODO::Senthil","instance":"Click_Box_92","roles":{"click":{"subtype":"button"}}},{"id":"Slide111149","class":"Normal Slide","instance":"Full Device Descriptor Use","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_969","What_is_ACPI_970","Click_Box_92"],"roles":{"slide":{"durationInFrames":957},"navigation":{"navid":"Slide111149"}}},{"id":"What_is_ACPI_text_971","class":"TODO::Senthil","instance":"What_is_ACPI_text_971","title":"An Augmented Device object uses ACPI to provide additional information for a device that is discoverable via an enumerable bus such as PCI or USB. Such bus-enumerated devices, including ACPI devices containing an _ADR object, may optionally supplement the bus-specified mechanisms for entering D-States.   For example, PCI devices report support for D-states through the PCI Power Management Capability Structure. This structure also contains a control register that PCI power management software can use to place a PCI function into a supported D-state, and to arm the function to generate a wake event. Supplemental platform-provided control methods or Power Resource objects can be provided to perform platform- or SoC-specific steps. Bus-specific power management techniques are described later in this module.  Note: Simple Peripheral Bus (SPB) devices (such as I2C) donâ€™t fall into the augmented device descriptor category, even though they are electrically children of controllers on a bus. Therefore, SPB devices can be put into low power states even when the parent controller is in D0.    ","roles":{"textData":{}}},{"id":"Green_underline_161","class":"TODO::Senthil","instance":"Green_underline_161","roles":{}},{"id":"What_is_ACPI_972","class":"TODO::Senthil","instance":"What_is_ACPI_972","title":"Augmented Descriptor Use ","roles":{"textData":{}}},{"id":"Click_Box_93","class":"TODO::Senthil","instance":"Click_Box_93","roles":{"click":{"subtype":"button"}}},{"id":"Slide111201","class":"Normal Slide","instance":"Augmented Descriptor Use","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_971","What_is_ACPI_972","Click_Box_93"],"roles":{"slide":{"durationInFrames":2046},"navigation":{"navid":"Slide111201"}}},{"id":"What_is_ACPI_text_1048","class":"TODO::Senthil","instance":"What_is_ACPI_text_1048","title":"Note that device drivers process bus requests to enter states D1, D2, or D3 before ACPI methods _PS1, _PS2, or _PS3 are invoked. Method  _PS0 is invoked prior to a bus request to enter D0.    The driver for a device first processes a request to enter D1, D2, or D3 state.  The bus driver then performs a bus-specific process to place the device into the requested D-State.  Then method _PS1, PS2, or PS3 is invoked.  On a return to D0 state, _PS0 is invoked first, then the bus driver, and then the device driver.   Interaction between the bus driver and device driver is specific to the OSPM implementation, and currently differs between Windows and Linux.    ","roles":{"textData":{}}},{"id":"Green_underline_190","class":"TODO::Senthil","instance":"Green_underline_190","roles":{}},{"id":"What_is_ACPI_1049","class":"TODO::Senthil","instance":"What_is_ACPI_1049","title":"Augmented Descriptor Use (continued) ","roles":{"textData":{}}},{"id":"Click_Box_114","class":"TODO::Senthil","instance":"Click_Box_114","roles":{"click":{"subtype":"button"}}},{"id":"Slide113289","class":"Normal Slide","instance":"Augmented Descriptor Use 2","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_1048","What_is_ACPI_1049","Click_Box_114"],"roles":{"slide":{"durationInFrames":1356},"navigation":{"navid":"Slide113289"}}},{"id":"What_is_ACPI_text_973","class":"TODO::Senthil","instance":"What_is_ACPI_text_973","title":"The ability for a device to generate a wake event is described to OSPM  using the following objects: _S0W is the object that determines the deepest D-State from which a device can generate a wake event while the system is in S0,         including Low Power S0 Idle. _S1W is the object that determines the deepest D-State from which a device can generate a wake event while the system is in S1. _S2W is the object that determines the deepest D-State from which a device can generate a wake event while the system is in S2. _S3W is the object that determines the deepest D-State from which a device can generate a wake event while the system is in S3. _S4W is the object that determines the deepest D-State from which a device can generate a wake event while the system is in S4.  These objects, if implemented as control methods, take no arguments, and must always return the same value, from 1-4: 1- Can wake from D1 2- Can wake from D1 and D2 3- Can wake from D1, D2, and D3hot 4- Can wake from D1-D3hot and D3cold; the latter is only valid if OSPM conveys support for D3cold via Platform-Wide Capabilities (_OSC).  Note that there is no _S5W object; OSPM does not control wake policy when the system is placed into the S5 system state .   ","roles":{"textData":{}}},{"id":"Click_Box_94","class":"TODO::Senthil","instance":"Click_Box_94","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_179","class":"TODO::Senthil","instance":"Green_underline_179","roles":{}},{"id":"What_is_ACPI_1009","class":"TODO::Senthil","instance":"What_is_ACPI_1009","title":"Wake Mechanisms ","roles":{"textData":{}}},{"id":"Slide111253","class":"Normal Slide","instance":"Wake Mechanisms","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_973","Click_Box_94","What_is_ACPI_1009"],"roles":{"slide":{"durationInFrames":2427},"navigation":{"navid":"Slide111253"}}},{"id":"What_is_ACPI_text_975","class":"TODO::Senthil","instance":"What_is_ACPI_text_975","title":"_DSW  (Device Sleep Wake) is a control method used to enable or disable a deviceâ€™s ability to generate a wake event:  When in Sx, this causes the system to resume to S0.  When in S0, this results in a notification to OSPM that the device is requesting entry to D0.   _DSW takes three arguments:   Arg0 is the enable/disable- 1 to enable/arm the wake logic, 0 to disable.  Arg1 is the target system state (0-4) Arg2 is the target D-state (0-3)  The _DSW method is generally only used to store target S- and D-State information when wake is enabled. This information is used during the control method(s) called when entering a D-state.   A device may use a different wake mechanism for D3(hot) verus D3(cold), or the platform may need to be configured differently for wake from S3 or S4 versus a runtime (S0) wake event. ","roles":{"textData":{}}},{"id":"Click_Box_95","class":"TODO::Senthil","instance":"Click_Box_95","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_178","class":"TODO::Senthil","instance":"Green_underline_178","roles":{}},{"id":"What_is_ACPI_1008","class":"TODO::Senthil","instance":"What_is_ACPI_1008","title":"Wake Mechanisms (continued) ","roles":{"textData":{}}},{"id":"Slide111305","class":"Normal Slide","instance":"Wake Mechanisms 2","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_975","Click_Box_95","What_is_ACPI_1008"],"roles":{"slide":{"durationInFrames":1722},"navigation":{"navid":"Slide111305"}}},{"id":"What_is_ACPI_text_977","class":"TODO::Senthil","instance":"What_is_ACPI_text_977","title":"Devices within a bus hierarchy (such as PCI or USB) cannot be placed into a deeper D-state than any of that deviceâ€™s children. This means that a PCI bridge/switch cannot be placed into D3 unless all devices beneath it are first placed into D3.   This relationship also enforces ordering: when an entire hierarchy of devices is placed into D3, those farthest away from the host CPU are put into D3 first. The reverse is true when bringing devices up to power state D0: devices closest to the host CPU are re-initialized first.  As previously mentioned, Simple Peripheral Bus (SPB) devices (such as I2C) donâ€™t fall into the augmented device descriptor category, even though they are electrically children of controllers on a bus. Therefore, SPB devices can be put into low power states even when the parent controller is in D0.   ","roles":{"textData":{}}},{"id":"Green_underline_164","class":"TODO::Senthil","instance":"Green_underline_164","roles":{}},{"id":"What_is_ACPI_978","class":"TODO::Senthil","instance":"What_is_ACPI_978","title":"Bus Relationships ","roles":{"textData":{}}},{"id":"Click_Box_96","class":"TODO::Senthil","instance":"Click_Box_96","roles":{"click":{"subtype":"button"}}},{"id":"Slide111357","class":"Normal Slide","instance":"Bus Relationships","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_977","What_is_ACPI_978","Click_Box_96"],"roles":{"slide":{"durationInFrames":1563},"navigation":{"navid":"Slide111357"}}},{"id":"What_is_ACPI_text_1041","class":"TODO::Senthil","instance":"What_is_ACPI_text_1041","title":"In addition to the _PS0/1/2/3 control methods used to place devices into D-States, device objects can also describe dependencies on Power Resources for specific D-states.  For example, ACPI Firmware can determine whether OSPM supports runtime device power management via the \\_SB._OSC System Capabilities, bit 2. This bit is set if OSPM supports reading _PR3 and using power resources to switch power. Note this handshake translates to an operating model that both the platform and OSPM support the power model containing D3hot and D3cold.  Generic Power Resources  A Power Resource is a separate object within the ACPI namespace. Power Resources are referenced by _PR0/1/2/3 objects within a Device object, as follows:   _PR0: The object is used to refer to a PowerResource required for a device to be in D0 state. If the same power rail/control is used to supply power to the device in D0 and D3(hot), both _PR0 and _PR3 should refer to the same PowerResource. _PR1: The object is used to refer to a power resource required for a device to be in D1 state. _PR2: This object is used to refer to a power resource required for a device to be in D2 state. _PR3: This object is used to refer to a power resource required for a device to be in D3(hot). The referenced power resource is turned off when the device is placed into D3(cold).  _PRW: This object is used to refer to a PowerResource required for a device to be armed to generate wake events.   ","roles":{"textData":{}}},{"id":"Green_underline_187","class":"TODO::Senthil","instance":"Green_underline_187","roles":{}},{"id":"What_is_ACPI_1042","class":"TODO::Senthil","instance":"What_is_ACPI_1042","title":"Power Resources  ","roles":{"textData":{}}},{"id":"Click_Box_112","class":"TODO::Senthil","instance":"Click_Box_112","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_1043","class":"TODO::Senthil","instance":"What_is_ACPI_text_1043","title":" ","roles":{"textData":{}}},{"id":"Slide113026","class":"Normal Slide","instance":"Power Resources","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_1041","What_is_ACPI_1042","Click_Box_112","What_is_ACPI_text_1043"],"roles":{"slide":{"durationInFrames":3162},"navigation":{"navid":"Slide113026"}}},{"id":"What_is_ACPI_text_979","class":"TODO::Senthil","instance":"What_is_ACPI_text_979","title":"A PowerResource object contains the following methods/objects:  _ON a control method used to turn on the power resource. _OFF a control method to turn off the power resource. _STA an object that returns the current state of the power resource- 1 for on, 0 for off _RST an optional control method used to reset devices within the power domain represented by the Power Resource.  A device uses _PR0/1/2/3 to list Power Resource objects that must be on for the corresponding D-state. The Power Resource(s) listed in _PR0 must be on while the device is in D0, and so forth. A Power Resource can be listed for multiple D-states- e.g. _PS0 and _PS3 can both refer to a single Power Resource object, which will only be turned off after the devices dependent on that Power Resource are ready to be placed into D3(cold).  Multiple devices can be logically grouped together into power domains, such that power to those devices is controlled by a single Power Resource. To accomplish this, each device lists the Power Resource dependency in their respective _PR0/1/2/3 objects.  _PRW is used to describe one or more Power Resources used to power wake logic, as well as the deepest system state from which a wake event can be generated, and information on how the wake event is signaled to OSPM. If a device is not armed for wake (via _DSW), the Power Resource(s) referenced by the device may turned off if not needed.   ","roles":{"textData":{}}},{"id":"Click_Box_97","class":"TODO::Senthil","instance":"Click_Box_97","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1015","class":"TODO::Senthil","instance":"Text_Caption_1015","title":"Example:  PowerResource(PR00){      Method(_ON){ \t    Store(1, _STA) \t    ...     } \t     Method(_OFF){ \t    Store(0, _STA) \t    ...     }      Name(_STA, 1)  // Default power-on state is On      Method(_RST){ \t    ...     } } ","roles":{"textData":{}}},{"id":"Green_underline_188","class":"TODO::Senthil","instance":"Green_underline_188","roles":{}},{"id":"What_is_ACPI_1045","class":"TODO::Senthil","instance":"What_is_ACPI_1045","title":"Generic Power Resources (continmued)  ","roles":{"textData":{}}},{"id":"Slide111409","class":"Normal Slide","instance":"Power Resources 2","thumbnail":"","children":["si74803","si112559","What_is_ACPI_text_979","Click_Box_97","Text_Caption_1015","What_is_ACPI_1045"],"roles":{"slide":{"durationInFrames":2823},"navigation":{"navid":"Slide111409"}}},{"id":"Click_Box_100","class":"TODO::Senthil","instance":"Click_Box_100","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_989","class":"TODO::Senthil","instance":"What_is_ACPI_text_989","title":"The native device power control for USB is Selective Suspend. The wake mechanism is called Remote Wake. USB maps Selective Suspend to both ACPI D2 and D3, where D2 is the state from which a USB device is armed for wake, and D3 when not armed for wake.  USB devices have a single power rail. It must be left on in D2 to power wake logic, but can be removed in D3. There is no architectural out-of-band reset mechanism other than cycling power. In-band reset is controlled by the USB host controller and bus driver.  An example of a PowerResource for a USB device is shown here.   ","roles":{"textData":{}}},{"id":"Green_underline_170","class":"TODO::Senthil","instance":"Green_underline_170","roles":{}},{"id":"What_is_ACPI_990","class":"TODO::Senthil","instance":"What_is_ACPI_990","title":"Bus-Specific Power Controls - USB   ","roles":{"textData":{}}},{"id":"What_is_ACPI_text_1011","class":"TODO::Senthil","instance":"What_is_ACPI_text_1011","title":"Device(UD00){\t        // USB device 0 \tName (_ADR, 1)\t    // USB port number of parent Hub \tName (_PR0, PRU1)\t// PRU1 required for both \tName (_PR2, PRU1)\t// D0 and D2 \tMethod (_PS0){ \t\t...     } \t     Method (_PS2){ \t\t...     }     Method (_PS3){ \t\t...     }  \t... }  PowerResource(PRU1){  \tMethod(_ON){ \t   // Apply power to USB Device UD00 \t   Sleep(10)\t    // Delay for power to stabilize, ms \t   Store(1, _STA)     } \t     Method(_OFF){ \t   Store(0, _STA) \t   // Remove power from USB Device UD00     }      Name(_STA, 1)\t// Default power-on state is On  } ","roles":{"textData":{}}},{"id":"Slide111607","class":"Normal Slide","instance":"Bus Controls - USB","thumbnail":"","children":["si74803","si112559","Click_Box_100","What_is_ACPI_text_989","What_is_ACPI_990","What_is_ACPI_text_1011"],"roles":{"slide":{"durationInFrames":1305},"navigation":{"navid":"Slide111607"}}},{"id":"Click_Box_102","class":"TODO::Senthil","instance":"Click_Box_102","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_994","class":"TODO::Senthil","instance":"What_is_ACPI_text_994","title":"PCI Express follows the model defined in the PCI Power Management Specification. It supports D0, D3(hot) and D3(cold). D1 and D2 are supported, but not clearly defined in how they differ from D3(hot).   In all states except for D3(cold), the PCI Express link is placed into L1 or a supported L1 Substate (L1.1 or L1.2). Power is not removed from the Endpoint, although it is required to self-manage power consumption. PCI config space is available, and the link will return to L0 in order to service config read and write transactions. The link also returns to L0 when an Endpoint generates a wake event, which it does by sending an in-band PME message upstream. Commands to enter D0-D3 are accomplished by a config write transaction to a field in the Power Management Capability Structure, the Power Management Control and Status Register (PMCSR).  Entry of a PCI Express Endpoint (EP) to D3(cold) occurs at the parent Downstream Port (DP), usually a Root Port (RP). The DP will only be commanded to enter D3 once all children are in D3(hot) and are prepared to enter D3(cold). Generally the Power Resource referenced by _PR3 is turned off at the end of the DP D3 entry sequence, and the _OFF method within that Power Resource is responsible for the D3(cold) entry sequence for endpoints beneath the DP.  ","roles":{"textData":{}}},{"id":"Green_underline_180","class":"TODO::Senthil","instance":"Green_underline_180","roles":{}},{"id":"What_is_ACPI_1012","class":"TODO::Senthil","instance":"What_is_ACPI_1012","title":"Bus-Specific Power Controls - PCI Express ","roles":{"textData":{}}},{"id":"Slide111725","class":"Normal Slide","instance":"PCI Express","thumbnail":"","children":["si74803","si112559","Click_Box_102","What_is_ACPI_text_994","What_is_ACPI_1012"],"roles":{"slide":{"durationInFrames":2694},"navigation":{"navid":"Slide111725"}}},{"id":"Click_Box_108","class":"TODO::Senthil","instance":"Click_Box_108","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_1025","class":"TODO::Senthil","instance":"What_is_ACPI_text_1025","title":"In order to enter D3(cold), there is an in-band protocol handshake used to tell a device to cease using the in-band wake mechanism (PME messages) and start using the sideband wake signal (WAKE#). The mechanism to invoke this sequence is device-specific, and may be available via controls/registers within the root/downstream port. Once this completes, fundamental reset (e.g. PERST#) is driven to the PCIe Endpoint, taking the link to L2 or L3. In D3(cold) core power is permitted to be removed.   The PCIe reference clock should be turned off, since the assertion of PERST# to a PCIe Endpoint caused the Endpoint to disable its clock power management feature, such that the Endpoint will drive CLKREQ# thereby requesting the reference clock.     If an Endpoint is not armed for wake, all of its power may be removed.   Some PCIe form factors (such as M.2) define a single power rail, which acts as the auxiliary power rail. This rail may be turned off only if the Endpoint is not armed for wake.   An example of a PCI Express Root Port and connected Endpoint supporting D3(cold) is shown here.   ","roles":{"textData":{}}},{"id":"Green_underline_183","class":"TODO::Senthil","instance":"Green_underline_183","roles":{}},{"id":"What_is_ACPI_1026","class":"TODO::Senthil","instance":"What_is_ACPI_1026","title":"Bus-Specific Power Controls - PCI Express ","roles":{"textData":{}}},{"id":"Text_Caption_1027","class":"TODO::Senthil","instance":"Text_Caption_1027","title":"Device(RP00)  // PCI Express Root Port 0 {   Name(_ADR, 0) // PCI Device/Function of this RP    Name (_S0W, 4)  // Supports wake from D3(cold)  \tName (_PR0, Package() {PRP0})\t// PRP0 is required for  \tName (_PR3, Package() {PRP0})\t// both D0 and D3(hot)    Method(_DSW){     // Collect target S- and D-states for use in arming wake events\\     // during D3(cold) entry via Power Resource _OFF Method   }    Device(EP00)  // Endpoint PCIe device connected to RP00   {     Name(_ADR, 0) // PCI Device/Function of this EP     ...   }    Method(_DSM, 4){     // PCI _DSM function 10 is used by OSPM to negotiate any required     // PCIe Aux Power budgeting, or to keep core power on in D3(cold)     // PCI _DSM function 11 is used by OSPM to collect any delay needed     // between the RP receipt of PM_TO_Ack and assertion of PERST#.   } } ","roles":{"textData":{}}},{"id":"Slide112640","class":"Normal Slide","instance":"PCI Express 2","thumbnail":"","children":["si74803","si112559","Click_Box_108","What_is_ACPI_text_1025","What_is_ACPI_1026","Text_Caption_1027"],"roles":{"slide":{"durationInFrames":2196},"navigation":{"navid":"Slide112640"}}},{"id":"Click_Box_109","class":"TODO::Senthil","instance":"Click_Box_109","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_1028","class":"TODO::Senthil","instance":"What_is_ACPI_text_1028","title":"The example shown in the two boxes below is of a Power Resource object used to place an EP into D3(cold) when referenced by _PR0 and _PR3 of the root port. Note that this also supports driving PCI Express Reset (PERST#) via the RST method. ","roles":{"textData":{}}},{"id":"Green_underline_184","class":"TODO::Senthil","instance":"Green_underline_184","roles":{}},{"id":"What_is_ACPI_1029","class":"TODO::Senthil","instance":"What_is_ACPI_1029","title":"Bus-Specific Power Controls - PCI Express ","roles":{"textData":{}}},{"id":"Text_Caption_1031","class":"TODO::Senthil","instance":"Text_Caption_1031","title":"  Method(_ON, 0){     // Platform-specific instructions go here, to meet the following steps     // Only perform these steps if Power Resource is off     If(LNot(_STA)) // or If(_STA != 1)     {       // Restore core (and aux, if off) power to Endpoint       // Enable PCIe refclock       // Wait required time (100 ms) prior to de-assertion of PERST       // Note- this delay is form-factor specific        Sleep (100)       // Deassert PERST#       Store(1, _STA)     }   }    Method(_RST){     // Platform-specific code to assert PERST# via GPIO     // Delay for form-factor-specific PERST# min assetion time     // Platform-specific code to de-assert PERST#, same GPIO   } }   // End of PRP0 ","roles":{"textData":{}}},{"id":"Text_Caption_1030","class":"TODO::Senthil","instance":"Text_Caption_1030","title":"PowerResource(PRP0) // Power Resource for devices connected to RP00 {   Name(_STA, 1) // Default power-on state is On    Method(_OFF, 0){     // Platform-specific instructions go here, to meet the following steps     // Only perform these steps if Power Resource is on     If(_STA)  // or If(_STA == 1)     {        // PCIe PME_Turn_Off, wait for PME_TO_Ack handshake (DP-specific)        // or timeout       // Insert any requested delay via PCI _DSM(10)       // Assert PERST#, GPIO       // Disable PCIe refclock       // Configure wake sideband wake GPIO to generate SCI (if armed for wake)        // Remove core power from Endpoint, unless _DSM(10) requires it left on       // Remove aux power from Endpoint if not armed for wake (optional)          Store(0, _STA)     }  ... ","roles":{"textData":{}}},{"id":"Slide112737","class":"Normal Slide","instance":"PCI Express 3","thumbnail":"","children":["si74803","si112559","Click_Box_109","What_is_ACPI_text_1028","What_is_ACPI_1029","Text_Caption_1031","Text_Caption_1030"],"roles":{"slide":{"durationInFrames":477},"navigation":{"navid":"Slide112737"}}},{"id":"Click_Box_110","class":"TODO::Senthil","instance":"Click_Box_110","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_1032","class":"TODO::Senthil","instance":"What_is_ACPI_text_1032","title":"There is an optimization used to reduce the amount of delay when a large number of devices are brought from D3(cold) to D0. In the _On Method, there is a required 100ms delay. To allow other work to proceed while waiting for this time to elapse, the _On method can make use of the ACPI Timer() as shown here. ","roles":{"textData":{}}},{"id":"Green_underline_185","class":"TODO::Senthil","instance":"Green_underline_185","roles":{}},{"id":"What_is_ACPI_1033","class":"TODO::Senthil","instance":"What_is_ACPI_1033","title":"Power-on Delay Optimization ","roles":{"textData":{}}},{"id":"Text_Caption_1035","class":"TODO::Senthil","instance":"Text_Caption_1035","title":"  Name(D0TM, 0) // D0 Entry Timer    Method(_ON, 0){     // Platform-specific instructions go here,      // to meet the following steps.      // Only perform these steps if Power Resource is off     If(LNot(_STA)) // or If(_STA != 1)     {       // Restore core (and aux, if off) power to Endpoint       // Enable PCIe refclock       // Disable sideband wake mechanism (GPIO)        // from generating SCI       // Wait required time (100 ms) for PCIe link training       Store(Add(Timer, 100000000), D0TM)         // Time when PERST# may be deasserted     }   }  ","roles":{"textData":{}}},{"id":"What_is_ACPI_text_1039","class":"TODO::Senthil","instance":"What_is_ACPI_text_1039","title":"Subsequently, the _PS0 Method can ensure that the required time has elapsed before de-asserting the PCIe reset signal (PERST#): ","roles":{"textData":{}}},{"id":"Text_Caption_1040","class":"TODO::Senthil","instance":"Text_Caption_1040","title":"  Method(_PS0, 0) {     Store(Timer(), TMR)      If(LLess(TMR, PRP0.DOTM)      { // Convert to mS and Sleep the remaining time       Sleep(Divide(Subtract(PRP0.DOTM, TMR), 1000000))      }     // Platform-specific code to de-assert PERST#, via GPIO   }  ","roles":{"textData":{}}},{"id":"Slide112839","class":"Normal Slide","instance":"Power-on Delay Optimization","thumbnail":"","children":["si74803","si112559","Click_Box_110","What_is_ACPI_text_1032","What_is_ACPI_1033","Text_Caption_1035","What_is_ACPI_text_1039","Text_Caption_1040"],"roles":{"slide":{"durationInFrames":882},"navigation":{"navid":"Slide112839"}}},{"id":"Click_Box_106","class":"TODO::Senthil","instance":"Click_Box_106","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_1013","class":"TODO::Senthil","instance":"What_is_ACPI_text_1013","title":"Unlike bus-enumerated devices, SPB devices are declared using Full Device Descriptors, those using a _HID object. While its Resource Descriptor object (_CRS) may reference one or more bus controllers, within ACPI and OSPM there is not a strict parent-child relationship like there is for PCI and USB. Therefore, SPB devices and controllers can be placed into D-states independently of each other.  Additionally, some SPB devices (like SPI and I2C) may reside on an electrical connection shared by other devices. In order to power-manage these devices independently of other devices, there may need to be some sort of on-board signal isolation used to prevent interference with devices sharing the same electrical connections.  For devices that have independent power controls, using a Power Resource object is optional. _PS0/1/2/3 control methods can be used directly. For a device that supports D0 and D3, it would include Control Methods similar to the ones shown in the code sample here.   Alternatively, Power Resource objects referenced by _PR0, _PR2, and _PR3 can be used instead, where the _ON would be equivalent to the _PS0 method, and _OFF would be equivalent to _PS3. Power Resources must be used where multiple devices share a single power control.   ","roles":{"textData":{}}},{"id":"Green_underline_181","class":"TODO::Senthil","instance":"Green_underline_181","roles":{}},{"id":"What_is_ACPI_1014","class":"TODO::Senthil","instance":"What_is_ACPI_1014","title":"SPB and Other Full Device Descriptors ","roles":{"textData":{}}},{"id":"Text_Caption_1024","class":"TODO::Senthil","instance":"Text_Caption_1024","title":"Name(DS, 0)\t// Current D-state  Method(_PS0, 0) {    If(LNotEqual(DS, 0))    { // Only needed if not already in D0      // Perform any necessary steps in this order,          // adding any delays needed:      // Restore device power      // Restore any clocks driving device      // Remove bus isolation      // De-assert any reset signal      Store(0, DS)          } } \t   Method(_PS3, 0) {    If(LEqual(DS, 0))    { // Only needed if current state is D0      // Perform any necessary steps in this order:       // Engage any bus isolation circuitry      // Assert any sideband reset signal       // Remove any clocks driving the device      // Remove device power      Store(DS, 3)    } } ","roles":{"textData":{}}},{"id":"Slide112200","class":"Normal Slide","instance":"Bus Controls - SPB","thumbnail":"","children":["si74803","si112559","Click_Box_106","What_is_ACPI_text_1013","What_is_ACPI_1014","Text_Caption_1024"],"roles":{"slide":{"durationInFrames":2442},"navigation":{"navid":"Slide112200"}}},{"id":"Click_Box_103","class":"TODO::Senthil","instance":"Click_Box_103","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_997","class":"TODO::Senthil","instance":"What_is_ACPI_text_997","title":"If a mixture of _PSx and _PRx methods is declared for a device, then the device states supported through both methods must be identical.   ","roles":{"textData":{}}},{"id":"Green_underline_173","class":"TODO::Senthil","instance":"Green_underline_173","roles":{}},{"id":"What_is_ACPI_998","class":"TODO::Senthil","instance":"What_is_ACPI_998","title":"Mixing PSx and PRx Methods ","roles":{"textData":{}}},{"id":"Slide111782","class":"Normal Slide","instance":"Mixing PSx and PRx Methods","thumbnail":"","children":["si74803","si112559","Click_Box_103","What_is_ACPI_text_997","What_is_ACPI_998"],"roles":{"slide":{"durationInFrames":228},"navigation":{"navid":"Slide111782"}}},{"id":"Text_Caption_722","class":"TODO::Senthil","instance":"Text_Caption_722","title":"Module Completion  ","roles":{"textData":{}}},{"id":"Text_Caption_723","class":"TODO::Senthil","instance":"Text_Caption_723","title":"Congratulations! Youâ€™ve completed this module. Close your browser to exit. ","roles":{"textData":{}}},{"id":"Image_198","class":"TODO::Senthil","instance":"Image_198","roles":{}},{"id":"Text_Caption_724","class":"TODO::Senthil","instance":"Text_Caption_724","title":"Module Completion  ","roles":{"textData":{}}},{"id":"Button_344","class":"TODO::Senthil","instance":"Button_344","roles":{"click":{"subtype":"button"}}},{"id":"si78825","class":"TODO::Senthil","roles":{"click":{"subtype":"button"}}},{"id":"si78839","class":"TODO::Senthil","roles":{"click":{"subtype":"button"}}},{"id":"Click_Box_68","class":"TODO::Senthil","instance":"Click_Box_68","roles":{"click":{"subtype":"button"}}},{"id":"Slide78225","class":"Normal Slide","instance":"Module Completion","thumbnail":"","children":["si74803","si112559","Text_Caption_722","Text_Caption_723","Image_198","Text_Caption_724","Button_344","si78825","si78839","Click_Box_68"],"roles":{"slide":{"durationInFrames":90},"navigation":{"navid":"Slide78225"}}},{"id":"Pool492","class":"pool","roles":{"pool":{"id":492,"name":"Pool1","questions":[]}}},{"id":"Device Power States","class":"project","title":"Device Power States","children":["Slide17873","Slide111858","Slide85337","Slide112536","Slide110983","Slide111149","Slide111201","Slide113289","Slide111253","Slide111305","Slide111357","Slide113026","Slide111409","Slide111607","Slide111725","Slide112640","Slide112737","Slide112839","Slide112200","Slide111782","Slide78225"],"roles":{"quiz":{"id":450,"branched":false,"submitAll":false,"review":false,"questions":[],"minScore":0,"maxScore":0,"passScore":10}}}],"contentSettings":{"global":{"branchAware":false},"toc":{"navigationEnabled":true,"navigateVisitedSlides":false,"collapseAll":false,"showTopicDuration":false,"statusFlag":true,"selfPaced":false,"showSearch":false,"enabled":true},"playbar":{"enabled":true,"cc":false,"playPause":true,"back":true,"forward":true,"rewind":false,"close":false,"mute":true,"progressBar":true}},"contentReporting":{"CCCriteria":"launch_content","SCCriteria":"launch_content","exitNormalIfCompleted":false},"toc":[{"id":"Slide17873","title":"Start","visible":false},{"id":"Slide111858","title":"About this Training","visible":true},{"id":"Slide85337","title":"Device Power States","visible":true},{"id":"Slide112536","title":"Device Power States 2","visible":false},{"id":"Slide110983","title":"Control Methods","visible":true},{"id":"Slide111149","title":"Full Device Descriptor Use","visible":true},{"id":"Slide111201","title":"Augmented Descriptor Use","visible":true},{"id":"Slide113289","title":"Augmented Descriptor Use 2","visible":false},{"id":"Slide111253","title":"Wake Mechanisms","visible":true},{"id":"Slide111305","title":"Wake Mechanisms 2","visible":false},{"id":"Slide111357","title":"Bus Relationships","visible":true},{"id":"Slide113026","title":"Power Resources","visible":true},{"id":"Slide111409","title":"Power Resources 2","visible":false},{"id":"Slide111607","title":"Bus Controls - USB","visible":true},{"id":"Slide111725","title":"PCI Express","visible":true},{"id":"Slide112640","title":"PCI Express 2","visible":false},{"id":"Slide112737","title":"PCI Express 3","visible":false},{"id":"Slide112839","title":"Power-on Delay Optimization","visible":true},{"id":"Slide112200","title":"Bus Controls - SPB","visible":true},{"id":"Slide111782","title":"Mixing PSx and PRx Methods","visible":true},{"id":"Slide78225","title":"Module Completion","visible":false}]}